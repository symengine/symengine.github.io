
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Design &#8212; Symengine latest documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/library/library.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="canonical" href="https://symengine.org/design/design.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Documentation Design" href="doc_design.html" />
    <link rel="prev" title="Design Details" href="index.html" />
 

<link rel="stylesheet" id="sphinx-library-type" href="../_static/library/type-book.css" type="text/css" />
<link rel="stylesheet" href="../_static/custom.css" type="text/css" />
<meta name="viewport" content="width=device-width, initial-scale=0.9" />
<script>
  mobile_menu_content = "";
  function toggleMenu() {
    var div = document.getElementsByClassName("document").item(0);
    var btn = document.getElementById("menu-toggler");
    if(div.classList.contains("mobile-show")) {
      div.classList.remove("mobile-show");
      btn.innerHTML = mobile_menu_content;
    }
    else {
      div.classList.add("mobile-show");
      mobile_menu_content = btn.innerHTML;
      btn.innerHTML = btn.getAttribute("data-open");
    }
  }
</script>
  </head>
<body class="sepia">
<div class="document">

  
  <nav class="mobile-menu" role="navigation">
    
  <button type="button" id="menu-toggler" onclick="toggleMenu();"
    data-open="× Close">≡ Menu</button>
  <a href="../index.html">Symengine</a>
  <noscript>
    <div>
      JavaScript is required to open/close mobile menu.
    </div>
  </noscript>
  </nav>
  

  
  <nav class="sphinxsidebar" role="navigation" aria-label="main navigation">
    


<h1 class="logo ">
  <a href="../index.html">Symengine</a>
</h1>





<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
<h3>Links</h3>
<ul>
  
  <li class="toctree-l1"><a href="https://github.com/Symengine">Github</a></li>
  
</ul>
<h3>Contents</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../use/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../inst/index.html">Production Usage</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design and Core Principles</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Library Design Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc_design.html">Documentation Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="style_guide.html">C++ Style Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../misc/faq.html">Frequently Asked Questions</a></li>
</ul>

<h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Design</a><ul>
<li><a class="reference internal" href="#symengine-is-used-in-different-languages">SymEngine is used in different languages</a></li>
<li><a class="reference internal" href="#reference-counted-pointers">Reference Counted Pointers</a><ul>
<li><a class="reference internal" href="#teuchos-rcp">Teuchos <code class="docutils literal notranslate"><span class="pre">RCP</span></code></a></li>
<li><a class="reference internal" href="#ptr-and-rcp"><code class="docutils literal notranslate"><span class="pre">Ptr</span></code> and <code class="docutils literal notranslate"><span class="pre">RCP</span></code></a></li>
<li><a class="reference internal" href="#uniqueptr"><code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code></a></li>
<li><a class="reference internal" href="#conclusion">Conclusion:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-creation-and-is-canonical">Object creation and <code class="docutils literal notranslate"><span class="pre">is_canonical()</span></code></a></li>
<li><a class="reference internal" href="#operator-overloading">Operator Overloading</a></li>
</ul>
</li>
</ul>
<script>
  function toggleMode(theme) {
    document.body.className = theme;
    localStorage.setItem("sphinx-library-mode", theme);
  }
  var theme = localStorage.getItem("sphinx-library-mode");
  if(theme !== null)
    toggleMode(theme);
</script>
<h3>Reading Mode</h3>

<button type="button" onclick="toggleMode('light');">Light</button>
<button type="button" onclick="toggleMode('sepia');">Sepia</button>
<button type="button" onclick="toggleMode('dark');">Dark</button>

<noscript>
  <div>
    JavaScript is required to toggle reading modes.
  </div>
</noscript>
  </nav>
  <div class="documentwrapper">
    <nav class="related breadcrumbs" role="navigation">
  <a class="nav-item" href="../index.html">Index</a>
  <span class="delim"> &#187;</span>
  <a class="nav-item" href="index.html">Design Details</a>
  <span class="delim"> &#187;</span>
  <span class="nav-item">Design</span>
    </nav>
    

    <main class="body" role="main" id="main">
      
  <div class="section" id="design">
<h1>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h1>
<p>Summary of our design decisions and some pointers to the literature.</p>
<div class="section" id="symengine-is-used-in-different-languages">
<h2>SymEngine is used in different languages<a class="headerlink" href="#symengine-is-used-in-different-languages" title="Permalink to this headline">¶</a></h2>
<p>The C++ SymEngine library doesn’t care about SymPy objects at all. We are just trying to implement things in some maintainable way, currently we settled on using <code class="docutils literal notranslate"><span class="pre">Basic</span></code>, <code class="docutils literal notranslate"><span class="pre">Mul</span></code>, <code class="docutils literal notranslate"><span class="pre">Pow</span></code>, … hierarchy and implement most functionality using the visitor pattern or single dispatch, so <code class="docutils literal notranslate"><span class="pre">Basic</span></code> doesn’t need many methods. We are keeping an option to perhaps do things differently if they turn out to be faster. Either way though, this shouldn’t matter at all for how it is actually used from Python, Ruby or Julia.</p>
<p>Let’s talk about just Python: the wrappers are in the <a class="reference external" href="https://github.com/symengine/symengine.py">symengine.py project</a>. They are implemented using Cython, and they are free to introduce any kind of classes (including SymPy’s <code class="docutils literal notranslate"><span class="pre">Expr</span></code> or Sage’s <code class="docutils literal notranslate"><span class="pre">Expression</span></code> if needed), and the point of the wrappers is to make sure that things work out of the box from SymPy and Sage. The only job of the C++ SymEngine library is to ensure that the library’s C++ API is implemented in such a way so that the wrappers can be written to do what they need. For example, we could easily introduce SymPy’s <code class="docutils literal notranslate"><span class="pre">Expr</span></code> into the wrappers, by simply introducing the <code class="docutils literal notranslate"><span class="pre">Expr</span></code> class and make all the other classes subclass from it instead of from <code class="docutils literal notranslate"><span class="pre">Basic</span></code>.</p>
<p>That was the reason we split the wrappers, so now in the (pure) C++ <code class="docutils literal notranslate"><span class="pre">symengine/symengine</span></code> repository, we only have to worry about speed, correctness, maintainability and a usable API, and we can concentrate on these things without worrying or even testing any kind of wrappers. In the wrappers (<code class="docutils literal notranslate"><span class="pre">symengine/symengine.py</span></code>, or <code class="docutils literal notranslate"><span class="pre">.jl</span></code>, <code class="docutils literal notranslate"><span class="pre">.rb</span></code>), we simply just use the C++ (or C) API and the only thing we care is so that the (Python) wrapper can be used from sympy/Sage (and we test that in the test suite), and that it doesn’t introduce unnecessary overhead in terms of speed. Ruby or Julia (or R) wrappers then care about interoperability with other libraries in those languages.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/symengine/symengine.py">https://github.com/symengine/symengine.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/symengine/symengine.rb">https://github.com/symengine/symengine.rb</a></p></li>
<li><p><a class="reference external" href="https://github.com/symengine/SymEngine.jl">https://github.com/symengine/SymEngine.jl</a></p></li>
<li><p><a class="reference external" href="https://github.com/symengine/symengine.R">https://github.com/symengine/symengine.R</a></p></li>
</ul>
</div>
<div class="section" id="reference-counted-pointers">
<h2>Reference Counted Pointers<a class="headerlink" href="#reference-counted-pointers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="teuchos-rcp">
<h3>Teuchos <code class="docutils literal notranslate"><span class="pre">RCP</span></code><a class="headerlink" href="#teuchos-rcp" title="Permalink to this headline">¶</a></h3>
<p>Memory management is handled by RCP (reference counted pointers) from
<code class="docutils literal notranslate"><span class="pre">Trilinos</span></code> (the module <code class="docutils literal notranslate"><span class="pre">Teuchos</span></code>). We have copied the relevant files into
<code class="docutils literal notranslate"><span class="pre">src/teuchos</span></code>, so no external dependencies need to be obtained. Brief code snippets of the
most frequent operations are given in our <a class="reference internal" href="style_guide.html"><span class="doc std std-doc">C++ Style
Guide</span></a>, and should be consulted if you are unsure about
the syntax. In order to understand how these pointers work under the hood, read the
<a class="reference external" href="https://docs.trilinos.org/dev/packages/teuchos/doc/html/RefCountPtrBeginnersGuideSAND.pdf">Teuchos::RCP Beginner’s
Guide</a> (pdf).
Finally, a more thorough exposition is given in <a class="reference external" href="https://docs.trilinos.org/dev/packages/teuchos/doc/html/TeuchosMemoryManagementSAND.pdf">Teuchos C++ Memory Management
Classes, Idioms, and Related Topics — The Complete
Reference</a>
(pdf).</p>
<p><code class="docutils literal notranslate"><span class="pre">Teuchos</span></code>’ RCP implements reference counting of objects, in the exact way Python
does. When an object runs out of scope, its reference count is decreased. When
it is copied, its reference count is increased. When the reference count goes to
zero, it is deallocated. This all happens automatically, so; as long as our C++
Style Guide is followed, things just work.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_TYPE=Debug</span></code> is set during the <code class="docutils literal notranslate"><span class="pre">CMake</span></code> build (which is the
default type), then <code class="docutils literal notranslate"><span class="pre">Teuchos</span></code> is compiled with debugging support, which means
that as long as the C++ Style Guide is followed; the C++ code should never
segfault (since no access is provided to raw pointers that could segfault and
<code class="docutils literal notranslate"><span class="pre">Teuchos</span></code> raises a nice exception with full stack trace instead of raising a
segfault if there is any problem; this too, is reminiscent of very similar to
Python). Use this mode when developing.</p>
<p>When the production build is used; by setting <code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_TYPE=Release</span></code>, then
<code class="docutils literal notranslate"><span class="pre">Teuchos</span></code> is compiled without debugging support, which means that all pointer
operations become either as fast as raw pointers, or very close. As such, there
is pretty much zero overhead. However, in this mode, the program can segfault if
you access memory incorrectly. This segfault however would be prevented under
<code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_TYPE=Debug</span></code>, so always use the Debug build to test your code, only
when all tests pass should you enable Release mode.</p>
<p>The Trilinos RCP pointers as described above are only used when the
<code class="docutils literal notranslate"><span class="pre">WITH_SYMENGINE_RCP=OFF</span></code> is set in <code class="docutils literal notranslate"><span class="pre">CMake</span></code>. The default option is
<code class="docutils literal notranslate"><span class="pre">WITH_SYMENGINE_RCP=ON</span></code>, which uses our own implementation of <code class="docutils literal notranslate"><span class="pre">RCP</span></code> (see
<code class="docutils literal notranslate"><span class="pre">src/symengine_rcp.h</span></code>). Our implementation is faster, but it only implements a
subset of all the functionality and it requires that all our objects have a
<code class="docutils literal notranslate"><span class="pre">refcount_</span></code> variable. Otherwise the usage of our in-house RCP and the
<code class="docutils literal notranslate"><span class="pre">Teuchos::RCP</span></code> are identical, and continuous integration tests run both
implementations of RCP to make sure the code works with both.</p>
</div>
<div class="section" id="ptr-and-rcp">
<h3><code class="docutils literal notranslate"><span class="pre">Ptr</span></code> and <code class="docutils literal notranslate"><span class="pre">RCP</span></code><a class="headerlink" href="#ptr-and-rcp" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">RCP</span></code> has an overhead with every assignment due to the change
(increase/decrease) in the <code class="docutils literal notranslate"><span class="pre">refcount</span></code>. You can access the inner pointer as <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>
(just call <code class="docutils literal notranslate"><span class="pre">.ptr()</span></code>), which has the same performance as raw pointer in Release
mode, yet it is 100% safe in Debug mode (i.e. if the original <code class="docutils literal notranslate"><span class="pre">RCP</span></code> goes out of
scope and the object deallocated; then the <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> becomes dangling, but you get a
nice exception raised in Debug mode on subsequent access attempts —- in
Release mode it will segfault or have undefined behavior, just like a raw
pointer). The idea is that for non-ownership access — i.e. typically when you
just want to read some term in <code class="docutils literal notranslate"><span class="pre">Add</span></code>, we should be passing around <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>, not
<code class="docutils literal notranslate"><span class="pre">RCP</span></code> (which has the extra <code class="docutils literal notranslate"><span class="pre">refcount</span></code> increment/decrement overhead, which
wasteful when we do not plan to own it). Such efficient implementations for the
basic classes have already been implmented in <code class="docutils literal notranslate"><span class="pre">SymEngine</span></code> and can be viewed <a class="reference external" href="https://github.com/symengine/symengine.py">in the API documentation</a>.</p>
</div>
<div class="section" id="uniqueptr">
<h3><code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code><a class="headerlink" href="#uniqueptr" title="Permalink to this headline">¶</a></h3>
<p>In terms of performance, the <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> is similar to implementations involving raw pointers and manual calls to new and delete, so there are no reasons to use such manual new/delete calls and raw pointers; instead; one should use <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>. One issue with <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> is that if you get access to the raw pointer using <code class="docutils literal notranslate"><span class="pre">.get()</span></code>, then it will segfault if this pointer becomes dangling (i.e. there are no Debug time checks implemented in the standard library for this because it returns a raw pointer, not a <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> object). This can however be fixed by writing a new class <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> that returns a <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> instead of a raw pointer and if you want to pass this around it is 100% Debug time checked, so it cannot segfault in Debug mode. Work on the implementation of this class has been ongoing in https://github.com/certik/trilinos/pull/1. The main bottleneck is that it needs to work with custom deallocators and be a drop-in replacement for <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, but it will be done in due time. The beauty of this new <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> class is that together with <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>, there will be no need to ever use manual new/delete calls and raw pointers. <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> has the same performance in Release mode, yet it is 100% safe in Debug mode and allows for having your cake and eating it too. It’s great.</p>
<p>However, the issue is that even manual new/delete patterns (or the equivalent <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code>) are slow, so we would like to avoid such operations, or perform them as little as possible. The feasibility of phasing out <code class="docutils literal notranslate"><span class="pre">RCP</span></code> in favor of <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> is still under consideration. The benefits are substantial. It would mean that for example, the <code class="docutils literal notranslate"><span class="pre">Add</span></code> container would deallocate its contents (i.e. instead of having a hashtable full of <code class="docutils literal notranslate"><span class="pre">RCP</span></code> objects, it would have a hashtable full of <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> objects), and on being accessed, would return a given term, which might just be a <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> (which is very fast, but could become dangling if <code class="docutils literal notranslate"><span class="pre">Add</span></code> goes out of scope — which would be checked at Debug time, so no segfault, but in Release builds it would segfault, and this error propagates for example; if one does an improper access at runtime from the Python wrappers in Release mode, it would segfault, which means then that the wrappers must be made aware of this behavior and prevented and must ensure such cases are not exposed to the user). Another simpler method is to make a copy of the object in such situations. For example, if you create some symbols and then use them in expressions, then currently we just pass around as <code class="docutils literal notranslate"><span class="pre">RCP</span></code>s, i.e. reference counted pointers to the original symbol. With the new approach, we would need to make a copy. Since we do not want to copy the <code class="docutils literal notranslate"><span class="pre">std::string</span></code> from inside Symbol, we want to store the symbols in some kind of table, and only pass a simple reference to the table (and also we need to deallocate things from the table if they are not used anymore). In other words, we just reinvented <code class="docutils literal notranslate"><span class="pre">RCP</span></code> again. So for Symbols, it seems that the <code class="docutils literal notranslate"><span class="pre">UniquePrt</span></code> wouldn’t have many benefits. There might be cases where this formulation has some benefit for classes like <code class="docutils literal notranslate"><span class="pre">Add</span></code>. If they internally use <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code>, we can do an optimization in Release mode and store the contents directly in the hashtable (i.e. with no pointers at all), and still pass around the <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> to other code (i.e in Debug mode it would use <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code>, thus we would make sure that things are not dangling, and in Release mode we just pass around <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>, with the performance of a raw pointer, to the internal array), that way we avoid new/delete. Also with this one can do custom allocator, i.e. allocate a chunk of memory for the hashtable, and just do a placement new. This has been tested by the lead developer (Óndrej) and he was surprised to find that, the performance wasn’t much different to <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> (for smaller objects it was a bit faster, but for larger objects — remember they are stored by value now — it was even slower). Also the creation time for each type, <code class="docutils literal notranslate"><span class="pre">RCP</span></code> and <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> was almost the same as well. The reason is that a simple refcount initialization is negligible in terms of time compared to the <code class="docutils literal notranslate"><span class="pre">new</span></code> call. What is slow is if you pass around <code class="docutils literal notranslate"><span class="pre">RCP</span></code> instead of <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>, because a raw pointer (which is what <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> is in Release mode) is much faster than a refcount increase/decrease. We should still investigate if we can get rid of new/delete using the approaches from this paragraph.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion:<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>We should pass around <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> instead of <code class="docutils literal notranslate"><span class="pre">RCP</span></code> whenever possible, and we can do this right away.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> (after it is implemented) whenever possible instead of <code class="docutils literal notranslate"><span class="pre">RCP</span></code> — though most places in <code class="docutils literal notranslate"><span class="pre">SymEngine</span></code> seem to require <code class="docutils literal notranslate"><span class="pre">RCP</span></code>. We should keep this in mind, there might still be one or two places where <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> is the way to go.</p></li>
<li><p>Never use raw new/delete calls and never use raw pointers (use <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> + <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>, and if it is not sufficient, use the slower <code class="docutils literal notranslate"><span class="pre">RCP</span></code> + <code class="docutils literal notranslate"><span class="pre">Ptr</span></code>).</p></li>
<li><p>Never pass pointers to some internal data — pass <code class="docutils literal notranslate"><span class="pre">Ptr</span></code> and have it checked at the Debug phase using <code class="docutils literal notranslate"><span class="pre">UniquePtr</span></code> in Debug mode, and use the data directly in Release mode</p></li>
</ul>
<p>As an example of the last point, e.g. to give access to an internal <code class="docutils literal notranslate"><span class="pre">std::map</span></code> (as a pointer, so that the map is not copied), here is how to do it:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="cp">#ifdef DEBUG_MODE</span>
    <span class="n">UniquePtr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">get_access</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#ifdef DEBUG_MODE</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">ptr</span><span class="p">();</span>
<span class="cp">#else</span>
        <span class="k">return</span> <span class="n">ptrFromRef</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="cp">#endif</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>That way, in debug mode, you can catch dangling references but in the optimized mode it is optimally fast.</p>
</div>
</div>
<div class="section" id="object-creation-and-is-canonical">
<h2>Object creation and <code class="docutils literal notranslate"><span class="pre">is_canonical()</span></code><a class="headerlink" href="#object-creation-and-is-canonical" title="Permalink to this headline">¶</a></h2>
<p>Classes like <code class="docutils literal notranslate"><span class="pre">Add</span></code>, <code class="docutils literal notranslate"><span class="pre">Mul</span></code>, <code class="docutils literal notranslate"><span class="pre">Pow</span></code> are initialized through their constructor using their internal representation. <code class="docutils literal notranslate"><span class="pre">Add</span></code>, <code class="docutils literal notranslate"><span class="pre">Mul</span></code> have a <code class="docutils literal notranslate"><span class="pre">coeff</span></code> and <code class="docutils literal notranslate"><span class="pre">dict</span></code>, while <code class="docutils literal notranslate"><span class="pre">Pow</span></code> has a <code class="docutils literal notranslate"><span class="pre">base</span></code> and an <code class="docutils literal notranslate"><span class="pre">exp</span></code>. There are restrictions on what <code class="docutils literal notranslate"><span class="pre">coeff</span></code> and <code class="docutils literal notranslate"><span class="pre">dict</span></code> can be (for example <code class="docutils literal notranslate"><span class="pre">coeff</span></code> cannot be zero in <code class="docutils literal notranslate"><span class="pre">Mul</span></code>, and if <code class="docutils literal notranslate"><span class="pre">Mul</span></code> is used inside <code class="docutils literal notranslate"><span class="pre">Add</span></code>, then <code class="docutils literal notranslate"><span class="pre">Mul</span></code>’s coeff must be one, etc.). All these restrictions are checked when <code class="docutils literal notranslate"><span class="pre">SYMENGINE_ASSERT</span></code> is enabled inside constructors using the <code class="docutils literal notranslate"><span class="pre">is_canonical()</span></code> method. In this manner, you don’t have to worry about creating <code class="docutils literal notranslate"><span class="pre">Add</span></code>/<code class="docutils literal notranslate"><span class="pre">Mul</span></code>/<code class="docutils literal notranslate"><span class="pre">Pow</span></code> with wrong arguments, as it will be caught by the tests. In the Release mode no checks are done, so you can construct <code class="docutils literal notranslate"><span class="pre">Add</span></code>/<code class="docutils literal notranslate"><span class="pre">Mul</span></code>/<code class="docutils literal notranslate"><span class="pre">Pow</span></code> very quickly. The idea is that depending on the algorithm, you sometimes know that things are already canonical, so you simply pass it directly to <code class="docutils literal notranslate"><span class="pre">Add</span></code>/<code class="docutils literal notranslate"><span class="pre">Mul</span></code>/<code class="docutils literal notranslate"><span class="pre">Pow</span></code> and you avoid expensive type checking and canonicalization. At the same time, you need to make sure that tests are still running with <code class="docutils literal notranslate"><span class="pre">SYMENGINE_ASSERT</span></code> enabled, so that <code class="docutils literal notranslate"><span class="pre">Add</span></code>/<code class="docutils literal notranslate"><span class="pre">Mul</span></code>/<code class="docutils literal notranslate"><span class="pre">Pow</span></code> is never in an inconsistent state.</p>
<p>The philosophy of SymEngine is that you impose as many restrictions as possible in the <code class="docutils literal notranslate"><span class="pre">is_canonical()</span></code> method for each class (and only check that in Debug mode), so that inside the class you can assume all those things can be taken for granted and thus call faster algorithms (e.g. in <code class="docutils literal notranslate"><span class="pre">Rational</span></code> you know it’s not an integer, so you don’t need to worry about that special case, at the same time if you have an integer, you are forced to use the <code class="docutils literal notranslate"><span class="pre">Integer</span></code> class, thus automatically using faster algorithms for just integers). Then the idea is to use the information about the algorithm to construct arguments of the SymEngine classes in canonical form and then call the constructor without any checks.</p>
<p>For cases where you can’t or don’t want to bother constructing in canonical form, we provide high-level functions like <code class="docutils literal notranslate"><span class="pre">add</span></code>, <code class="docutils literal notranslate"><span class="pre">mul</span></code>, <code class="docutils literal notranslate"><span class="pre">pow</span></code>, <code class="docutils literal notranslate"><span class="pre">rational</span></code>, where you just provide arguments that are not necessarily in canonical form, and these functions will check and simplify. E.g. <code class="docutils literal notranslate"><span class="pre">add(x,</span> <span class="pre">x)</span></code> will check and simplify to <code class="docutils literal notranslate"><span class="pre">Mul(2,</span> <span class="pre">x)</span></code>, e.g. you never have the instance <code class="docutils literal notranslate"><span class="pre">Add(x,</span> <span class="pre">x)</span></code>. In the same spirit, <code class="docutils literal notranslate"><span class="pre">rational(2,</span> <span class="pre">1)</span></code> will check and convert to <code class="docutils literal notranslate"><span class="pre">Integer(2)</span></code>, e.g. you never have <code class="docutils literal notranslate"><span class="pre">Rational(2,</span> <span class="pre">1)</span></code>.</p>
<p>Summary: always try to construct objects directly using their constructors and all the knowledge that you have for the given algorithm, that way things will be very fast. If you want slower but simpler code, you can use the <code class="docutils literal notranslate"><span class="pre">add()</span></code>, <code class="docutils literal notranslate"><span class="pre">mul()</span></code>, <code class="docutils literal notranslate"><span class="pre">pow()</span></code>, <code class="docutils literal notranslate"><span class="pre">rational()</span></code> functions that perform general and possibly slow canonicalization first.</p>
</div>
<div class="section" id="operator-overloading">
<h2>Operator Overloading<a class="headerlink" href="#operator-overloading" title="Permalink to this headline">¶</a></h2>
<p>Ideally, we would like to be able to do:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RCP&lt;Basic&gt; x  = make_rcp&lt;Symbol&gt;(&quot;x&quot;);
RCP&lt;Basic&gt; y  = make_rcp&lt;Symbol&gt;(&quot;y&quot;);
RCP&lt;Basic&gt; r = (x + y) + (y + x);
std::cout &lt;&lt; r &lt;&lt; std::endl;
</pre></div>
</div>
<p>But the problem is, that the <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operations must be defined on the <code class="docutils literal notranslate"><span class="pre">RCP</span></code> objects.
However, just as you should not redefine what <code class="docutils literal notranslate"><span class="pre">double</span> <span class="pre">+</span> <span class="pre">double</span></code> is, you should not try to redefine operator overloading for an existing type (<code class="docutils literal notranslate"><span class="pre">RCP</span></code>). We can override operators for <code class="docutils literal notranslate"><span class="pre">Basic</span></code> objects, like so:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>((*x) + (*y)) + ((*y) + (*x))
</pre></div>
</div>
<p>But here the problem is that the <code class="docutils literal notranslate"><span class="pre">+</span></code> operator only gets access to <code class="docutils literal notranslate"><span class="pre">Basic</span></code>, but it needs to access <code class="docutils literal notranslate"><span class="pre">RCP&lt;Basic&gt;</span></code>
for memory management. In order to allow for operator overloaded types that use dynamic memory allocation, we will need to create our own “handle” classes. It is hard to write a handle class in C++ that are const-correct and clean and simple to use for most C++ developers. It can be done, but it is very hard, especially since
we care about performance. In our opinion, we are better off writing such a layer in Python.
An example of handle classes is [2] — it is non-const correct, but should give the ok performance.</p>
<p>Solution: using non-member non-friend functions is much more clear and much cleaner:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>add(add(x, y), add(y, x))
</pre></div>
</div>
<p>The function signature of <code class="docutils literal notranslate"><span class="pre">add</span></code> is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inline RCP&lt;Basic&gt; add(const RCP&lt;Basic&gt; &amp;a, const RCP&lt;Basic&gt; &amp;b);
</pre></div>
</div>
<p>For more complicated expressions, instead of <code class="docutils literal notranslate"><span class="pre">add</span></code>, we might also consider
using the naming scheme proposed in [1]. Another advantage of this approach is
that compiler errors are much easier to understand since it either finds
our function or it does not, while when overloading operators of our templated
classes (and RCP), any mistake typically results in pages of compiler errors in
gcc.</p>
<p>The Python wrappers then just call this <code class="docutils literal notranslate"><span class="pre">add</span></code> function and provide natural mathematical syntax <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">+</span> <span class="pre">(y</span> <span class="pre">+</span> <span class="pre">x)</span></code> at the Python level.</p>
<p>[1] <a class="reference external" href="https://docs.trilinos.org/dev/packages/thyra/doc/html/LinearAlgebraFunctionConvention.pdf">https://docs.trilinos.org/dev/packages/thyra/doc/html/LinearAlgebraFunctionConvention.pdf</a></p>
<p>[2] <a class="reference external" href="http://www.math.ttu.edu/~kelong/Playa/html/">http://www.math.ttu.edu/~kelong/Playa/html/</a></p>
</div>
</div>


    </main>
    <nav class="related bottom" role="navigation">
  <a class="prev" href="index.html" title="Previous">
    &larr; Design Details
  </a>
  <a class="next" href="doc_design.html" title="Next">
    Documentation Design &rarr;
  </a>
  <div class="clear"></div>
    </nav>
    

  </div>

  <div class="clear"></div>
</div>
<footer class="footer" role="contentinfo">
    &copy; Copyright 2021, Symengine Development Team.
  
  Created using <a href="http://sphinx-doc.org/">Sphinx</a> with
  <a href="https://github.com/vsalvino/sphinx-library">Library</a> theme.
  
  <a href="../_sources/design/design.md.txt" rel="nofollow">Page source</a>
</footer>
  </body>
</html>